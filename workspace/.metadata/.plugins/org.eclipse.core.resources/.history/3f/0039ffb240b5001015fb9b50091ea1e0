/*
 * HexDiff.cpp
 *
 *  Created on: 19/07/2011
 *      Author: josue
 */

#include "HexDiff.h"

HexDiff::HexDiff(XNA posSet, XNA negSet, XNA testSet, int lengthHd,
		int windowSize, double threshold) {
	this->posSet = posSet;
	this->negSet = negSet;
	this->testSet = testSet;
	this->lengthHd = lengthHd;
	this->windowSize = windowSize;
	this->threshold = threshold;
}

HexDiff::~HexDiff() {
	// TODO Auto-generated destructor stub
}

void HexDiff::performFrequency() {
	Freq posFq;
	Freq negFq;
	int posLength = posSet.chain.size();
	int negLength = negSet.chain.size();

	//Add the compliment on the positive sequence set
	for (int m = 0; m < posLength; ++m) {
		//posSet.addSeq(posSet.chain[m].compliment());
		posSet.addSeq(posSet.chain[m].reverse_compliment());
	}

	//Add the compliment on the negative sequence set
	for (int n = 0; n < negLength; ++n) {
		//negSet.addSeq(negSet.chain[n].compliment());
		negSet.addSeq(negSet.chain[n].reverse_compliment());
	}
	posSet.writeFasta("posSet.fasta");
	negSet.writeFasta("negSet.fasta");
/*
	XNAseq s;
	// First hexamer to compute
	s.seq = "AAAAAA";
	double ratio = 0;
	int i = 0;
	int cont = pow(4.0, 6);
	while (i < cont) {

		posFq = computeFrequency(posSet, s);
		negFq = computeFrequency(negSet, s);

		// find the ratio between positive and negative set
		if ((posFq.freq == 0) || (negFq.freq == 0)) {
			ratio = 0;
		} else {
			ratio = posFq.freq / negFq.freq;
		}
		HexRatio hexR(posFq.olig, ratio);
		Hd.push_back(hexR);
		s = nextLeaf(s, 6);
		i++;
	}
*/

}
void HexDiff::chooseHexamers() {
	Hd.sort(compareRatio);
	list<HexRatio>::iterator it1, it2;
	it1 = Hd.begin();
	it2 = Hd.end();
	advance(it1, lengthHd);
	Hd.erase(it1, it2);
}

void HexDiff::computeScore() {
	XNA tmpSet;
	XNAseq tmpSeq;
	list<HexRatio>::iterator it;
	Freq freq;
	double sum = 0;
	for (int i = 0; i < ((testSet.chain[0].length() - windowSize) + 1); ++i) {
		tmpSeq.seq = testSet.chain[0].seq.substr(i, windowSize);
		tmpSet.addSeq(tmpSeq);
		// Compute the frequency for each Hd in the test Set
		for (it = Hd.begin(); it != Hd.end(); ++it) {
			freq = computeFrequency(tmpSet, it->getHex());
			sum = sum + (freq.freq * it->getRatio());
		}
		if (sum > threshold) {
			Score s(i, sum);
			scoreList.push_back(s);
		}
		tmpSeq.clear();
		tmpSet.chain.clear();
		sum = 0;
	}
}

void HexDiff::printHd() {
	list<HexRatio>::iterator it;
	for (it = Hd.begin(); it != Hd.end(); ++it) {
		cout << it->getHex().seq << ' ' << it->getRatio() << endl;
	}
}

void HexDiff::printScore() {
	list<Score>::iterator it;
	for (it = scoreList.begin(); it != scoreList.end(); ++it) {
		cout << "position: " << it->getPosition() << "   score: "
				<< it->getScore() << endl;
	}
}
/********************
 * HexRatio Methods *
 ********************/
HexRatio::HexRatio(XNAseq hex, double ratio) {
	this->hex = hex;
	this->ratio = ratio;
}
XNAseq HexRatio::getHex() const {
	return hex;
}

double HexRatio::getRatio() const {
	return ratio;
}

void HexRatio::setHex(XNAseq hex) {
	this->hex = hex;
}

void HexRatio::setRatio(double ratio) {
	this->ratio = ratio;
}

/*****************
 * Score Methods *
 *****************/
Score::Score(int position, double score) {
	this->position = position;
	this->score = score;
}

int Score::getPosition() const {
	return position;
}

double Score::getScore() const {
	return score;
}

void Score::setPosition(int position) {
	this->position = position;
}

void Score::setScore(double score) {
	this->score = score;
}

bool compareRatio(HexRatio first, HexRatio second) {
	if (first.getRatio() > second.getRatio()) {
		return true;
	} else {
		return false;
	}

}
